# プランニング（STRIPS）

## 要点
- 行動を「前提条件・効果（追加/削除）」で形式化し計画生成。
- 状態は命題集合、ゴール充足へ状態空間探索（例：A*）。
- 古典的プランニングの代表。PDDLに継承され広く利用。

## 定義
- STRIPSは状態を命題の集合、行動を「前提条件」と「効果（追加リスト/削除リスト）」で定義し、適用可能性に基づく状態遷移で計画を得る。

## 重要キーワード
- 前提条件（Precondition）：行動適用に必要な命題集合。
- 追加リスト（Add-list）：適用後に真になる命題。
- 削除リスト（Delete-list）：適用後に偽になる命題。
- 適用可能性：前提条件が現状態で満たされていること。
- 状態空間探索：ゴール条件を満たす行動系列の探索。
- ゴール条件：達成すべき命題集合。
- PDDL（Planning Domain Definition Language）：プランニング記述言語。STRIPS系の表現を一般化。
- HTN（Hierarchical Task Network）：階層型タスクネットワーク。STRIPSとは表現・手続きが異なる。
- オペレータ（Operator）：行動の形式的記述単位。
- 命題論理：真偽値をとる論理式で状態を表現。

## 詳細

### 背景と直観
STRIPS（Stanford Research Institute Problem Solver）は1971年にNilssonらが開発したロボット行動計画システムです。ロボットが複数の部屋を移動し物体を操作する問題を解くために設計され、古典的プランニング手法の基礎となりました。

**基本的な考え方**は、以下の通りです：
- 世界の状態を「真である命題の集合」で表現
- 行動（オペレータ）を「前提条件→効果」の形で定義
- 初期状態からゴール状態へ至る行動系列を探索で発見

### STRIPSの形式化

**1. 状態（State）**
- 状態 $S$ は命題の集合：$S = \{p_1, p_2, ..., p_n\}$
- 例：`{At(Robot, RoomA), Clear(Box), Holding(Nothing)}`

**2. オペレータ（Action/Operator）**
各オペレータは3要素で構成：
- **前提条件（Precondition）**：$Pre(a)$ - 行動実行に必要な命題集合
- **追加リスト（Add-list）**：$Add(a)$ - 実行後に真になる命題
- **削除リスト（Delete-list）**：$Del(a)$ - 実行後に偽になる命題

**3. 状態遷移**
状態 $S$ でオペレータ $a$ を適用すると：
$$S' = (S \setminus Del(a)) \cup Add(a)$$

### 具体例：ブロックワールド

**問題設定**
- 初期状態：`{On(A,Table), On(B,Table), Clear(A), Clear(B), HandEmpty}`
- ゴール：`{On(B,A)}`

**オペレータ例：Pick(x)**
```
Precondition: {Clear(x), On(x,Table), HandEmpty}
Delete:       {Clear(x), On(x,Table), HandEmpty}
Add:          {Holding(x)}
```

**オペレータ例：Stack(x,y)**
```
Precondition: {Holding(x), Clear(y)}
Delete:       {Holding(x), Clear(y)}
Add:          {On(x,y), Clear(x), HandEmpty}
```

**解決計画**
1. `Pick(B)` → 状態：`{On(A,Table), Clear(A), Holding(B)}`
2. `Stack(B,A)` → 状態：`{On(A,Table), On(B,A), Clear(B), HandEmpty}`

### プランニング探索プロセス

```
初期状態
  ↓ [適用可能なオペレータを列挙]
中間状態1, 中間状態2, ...
  ↓ [ゴール条件チェック]
  ↓ [未達成なら続行]
  ↓ [ヒューリスティック（例：未達成ゴール数）で評価]
  ↓ [A*、幅優先探索などで展開]
ゴール状態到達
  → 解（行動系列）を抽出
```

### 図解：状態遷移の例

```
[初期] At(R,A), Clear(Box)
         ↓ Move(R,A,B)
   At(R,B), Clear(Box)
         ↓ PickUp(Box)
   At(R,B), Holding(Box)
         ↓ Move(R,B,C)
[ゴール] At(R,C), Holding(Box)
```

### STRIPSの制約と特徴

**制約**
- 命題論理のみ（変数・量化子なし）→拡張でADL、PDDLが登場
- 決定的世界（不確実性なし）
- 完全観測可能
- 単一エージェント

**利点**
- シンプルで理解しやすい
- 探索アルゴリズムと組み合わせ可能（A*、幅優先など）
- 形式的検証が容易

**欠点**
- 表現力の限界（否定、条件分岐、数値制約など）
- フレーム問題への対処（変化しない命題を明示不要とする工夫）

### 実世界への応用

- **ロボティクス**：移動・操作計画
- **ゲームAI**：NPC行動生成
- **スケジューリング**：作業計画最適化
- **自動化**：ワークフロー生成

## 試験での問われ方
- **典型設問**：「前提条件・行動・結果で記述する手法は？」→ **STRIPS**
- **比較されやすい概念**：
  - **A*** vs STRIPS：A*は**探索アルゴリズム**、STRIPSは**表現手法**（組み合わせて使う）
  - **PDDL** vs STRIPS：PDDLはSTRIPSを含む**記述言語**、STRIPSは基本**表現形式**
  - **HTN** vs STRIPS：HTNは**階層型タスク分解**、STRIPSは**状態空間探索**
- **引っ掛けポイント**：
  - 「結果」≒「効果（追加/削除リスト）」の用語対応
  - 前提条件の充足＝適用可能性の確認が必須
  - 探索手法（A*）と表現形式（STRIPS）の混同に注意
  - ゴール条件が「達成すべき命題の部分集合」であることを確認
- **頻出パターン**：
  - 「次に適用可能なオペレータを選べ」→前提条件が満たされているか確認
  - 「状態遷移後の命題を選べ」→削除リストと追加リストの正確な適用
  - 「計画不可能な理由は？」→適用可能なオペレータの不在やゴール到達不可

## 補足
- 実務的観点（任意）：多くのプランナはPDDLを用いる。精度と可搬性はドメイン/問題のモデリング品質（行動スキーマ、前提・効果の設計）に依存。
