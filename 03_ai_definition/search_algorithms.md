# 探索アルゴリズム（幅優先探索・深さ優先探索）

## 要点（試験用）
- **幅優先探索（BFS）**: 同階層を全て探索後に次階層へ。キュー使用、最短経路保証、メモリ大。
- **深さ優先探索（DFS）**: 深さ方向に進む。スタック使用、最短保証なし、メモリ小。
- A*は**ヒューリスティック探索**で評価関数 $f(n) = g(n) + h(n)$ で効率化。

## 定義
探索アルゴリズムは、問題空間（状態空間）内で目標状態に到達する経路を見つける手法。代表的な手法に**幅優先探索（BFS）**と**深さ優先探索（DFS）**がある。

## 重要キーワード
- **幅優先探索（BFS: Breadth-First Search）**: 同階層のノードを全て探索してから次階層へ進む探索手法。
- **深さ優先探索（DFS: Depth-First Search）**: 一つの分岐を最深部まで探索してからバックトラックする手法。
- **キュー（Queue）**: FIFO（First In First Out）構造。BFSで使用。
- **スタック（Stack）**: LIFO（Last In First Out）構造。DFSで使用。
- **完全性（Completeness）**: 解が存在すれば必ず見つけられること。
- **最適性（Optimality）**: 最短経路・最小コストの解を保証すること。
- **時間計算量**: 探索にかかる時間（ノード展開数）。
- **空間計算量**: メモリ使用量（保持するノード数）。
- **A*探索**: ヒューリスティック関数 $h(n)$ を用いた効率的探索。
- **ダイクストラ法**: 最短経路探索（重み付きグラフ）。
- **反復深化探索（IDS）**: DFSの深さ制限を段階的に増やす手法。

## 詳細（教科書風）

### 背景と直観
探索アルゴリズムは、迷路・パズル・経路探索・ゲーム木探索など幅広い問題に適用される基本技術です。探索の順序とデータ構造の選択が、性能と解の質を決定します。

**基本的な考え方**：
- 初期状態から可能な行動を展開
- 未探索ノードを適切な順序で選択
- 目標状態に到達するまで繰り返し

### 幅優先探索（BFS: Breadth-First Search）

#### アルゴリズム
```
1. 初期ノードをキューに追加
2. キューからノードを取り出す（FIFO）
3. 目標判定：ゴールなら終了
4. 未訪問の隣接ノードを全てキューに追加
5. 2へ戻る
```

#### 図解：探索順序
```
        1
      / | \
     2  3  4
    /|  |  |\
   5 6  7  8 9

探索順序: 1 → 2, 3, 4 → 5, 6, 7, 8, 9
（階層ごとに左から右へ）
```

#### 特徴
**利点**：
- **最短経路保証**（エッジコスト一定時）
- **完全性**：解が存在すれば必ず発見
- 浅い解を優先的に発見

**欠点**：
- **メモリ消費大**：全階層のノードを保持
- 深い解には不向き
- 分岐数 $b$、深さ $d$ のとき空間計算量 $O(b^d)$

#### 適用例
- 迷路の最短経路
- SNSの友達関係（○○さんまで何ステップ？）
- Webクローラー（リンク探索）
- パズルゲーム（最少手数）

### 深さ優先探索（DFS: Depth-First Search）

#### アルゴリズム
```
1. 初期ノードをスタックに追加
2. スタックからノードを取り出す（LIFO）
3. 目標判定：ゴールなら終了
4. 未訪問の隣接ノードをスタックに追加
5. 2へ戻る
```

#### 図解：探索順序
```
        1
      / | \
     2  3  4
    /|  |  |\
   5 6  7  8 9

探索順序: 1 → 2 → 5 → 6 → 3 → 7 → 4 → 8 → 9
（深さ優先で一本道を進む）
```

#### 特徴
**利点**：
- **メモリ消費小**：現在の経路のみ保持
- 深い解の発見が速い場合あり
- 空間計算量 $O(bd)$（$b$:分岐、$d$:深さ）

**欠点**：
- **最短保証なし**：最初に見つけた解が最短とは限らない
- 無限ループの可能性（循環検出が必要）
- 非常に深い経路で時間がかかる

#### 適用例
- トポロジカルソート
- 迷路探索（解の存在確認）
- バックトラック問題（ナップサック、N-Queen）

### BFS vs DFS 比較表

| 項目 | 幅優先探索（BFS） | 深さ優先探索（DFS） |
|------|-------------------|---------------------|
| **探索順序** | 階層ごと（横方向） | 深さ優先（縦方向） |
| **データ構造** | **キュー（FIFO）** | **スタック（LIFO）** |
| **最短経路** | **保証あり** | 保証なし |
| **完全性** | ○（有限空間で保証） | △（無限深さで×） |
| **時間計算量** | $O(b^d)$ | $O(b^m)$（$m$:最大深さ） |
| **空間計算量** | $O(b^d)$（大） | $O(bd)$（小） |
| **適用場面** | 最短経路、浅い解 | メモリ制約、深い解 |

### ヒューリスティック探索（A*）

#### 概要
A*探索は、**コスト関数 $g(n)$（実際のコスト）**と**ヒューリスティック関数 $h(n)$（推定コスト）**を組み合わせて効率化：

$$f(n) = g(n) + h(n)$$

- $g(n)$: 開始ノードから $n$ までの実コスト
- $h(n)$: $n$ からゴールまでの推定コスト（許容的ヒューリスティック）
- $f(n)$: 総推定コスト

#### 特徴
- **最適性**：$h(n)$ が許容的（真のコスト以下）なら最短保証
- **効率性**：BFSより探索ノード数が少ない
- **適用例**：カーナビ、ゲームAI、ロボット経路計画

#### 代表的ヒューリスティック
- **マンハッタン距離**：グリッド上の移動（$|x_1 - x_2| + |y_1 - y_2|$）
- **ユークリッド距離**：直線距離（$\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$）

### その他の探索手法

#### 反復深化探索（IDS: Iterative Deepening Search）
- DFSの深さ制限を段階的に増やす（深さ1→2→3...）
- BFSのメモリ効率とDFSの空間効率を両立
- 空間計算量 $O(d)$、時間計算量 $O(b^d)$

#### ダイクストラ法
- 重み付きグラフの最短経路探索
- A*の $h(n) = 0$ の特殊ケース
- 優先度付きキューで最小コストノードを選択

#### ベルマン・フォード法
- 負の重みを許容する最短経路探索
- 負閉路の検出可能

### 実装例（擬似コード）

#### BFS
```python
def bfs(start, goal):
    queue = [start]
    visited = {start}
    
    while queue:
        node = queue.pop(0)  # FIFO
        if node == goal:
            return "Found"
        
        for neighbor in node.neighbors:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return "Not Found"
```

#### DFS
```python
def dfs(start, goal, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(start)
    if start == goal:
        return "Found"
    
    for neighbor in start.neighbors:
        if neighbor not in visited:
            result = dfs(neighbor, goal, visited)
            if result == "Found":
                return "Found"
    
    return "Not Found"
```

## 探索・推論が適した問題と不適切な問題

### 探索・推論が適した問題（試験頻出）

| 問題タイプ | 理由 | 代表例 |
|----------|------|--------|
| **経路探索** | 状態＝位置、明確なゴール | 迷路、ナビゲーション、配送最適化 |
| **パズル** | 状態遷移が明確、制約条件あり | 8パズル、15パズル、ルービックキューブ |
| **ゲーム** | ルールが明確、勝敗判定可能 | チェス、将棋、囲碁（探索+評価） |
| **プランニング** | 行動の前提条件と効果が定義可能 | STRIPS、ロボット動作計画 |
| **制約充足問題（CSP）** | 制約条件が明示可能 | スケジューリング、資源配分 |
| **論理推論** | 命題・述語論理で記述可能 | エキスパートシステム、定理証明 |

**共通する特徴（適用条件）**：
- ✅ 状態空間が**離散的**に定義できる
- ✅ 遷移ルールが**明確**
- ✅ ゴール状態が**判定可能**
- ✅ 問題が**記号的**に表現できる

### 探索・推論が不適切な問題（試験で最重要）

| 問題タイプ | 理由 | 適切な手法 |
|----------|------|-----------|
| **画像認識** | ピクセル値から特徴抽出が必要、ルール化困難 | **CNN（深層学習）** |
| **音声認識** | 連続的な音響信号、話者・環境に依存 | **RNN/Transformer** |
| **自然言語処理** | 曖昧性、文脈依存、意味理解が必要 | **Transformer/LLM** |
| **手書き文字認識** | パターンの多様性、ルール化不可能 | **CNN/機械学習** |
| **異常検知** | 正常パターンの統計的把握が必要 | **機械学習（教師なし）** |
| **時系列予測** | 連続値、確率的変動 | **RNN/LSTM/統計モデル** |
| **感情分析** | 言語の曖昧性、文脈依存 | **Transformer/NLP** |

**共通する特徴（不適用条件）**：
- ❌ 状態空間が**連続的・高次元**
- ❌ ルールを**明示的に記述できない**
- ❌ **パターン認識**や**統計的推定**が必要
- ❌ **不確実性**が本質的に含まれる

### ハイブリッドアプローチ（境界領域）
現代のAIでは探索と学習を組み合わせる例もある：

- **AlphaGo**: モンテカルロ木探索（MCTS）+ 深層学習（価値・方策ネットワーク）
- **強化学習**: 探索（行動選択）+ 学習（価値関数の更新）
- **ニューロシンボリックAI**: 記号的推論と深層学習の統合

ただし、**主手法は深層学習**であり、探索は補助的。試験では「探索が主手法として適切か」を問う。

---

## 試験での問われ方

### 典型設問（探索手法の選択）
- 「同階層を全て探索後に次階層へ進む手法は？」→ **幅優先探索（BFS）**
- 「深さ方向に進む探索は？」→ **深さ優先探索（DFS）**
- 「最短経路を保証する探索は？」→ **幅優先探索（BFS）**（コスト一定時）
- 「メモリ消費が少ない探索は？」→ **深さ優先探索（DFS）**

### 典型設問（適用問題の判定）
**問：探索・推論の手法が適した問題として、最も不適切な選択肢を1つ選べ**

✅ **適切な選択肢**：
- 「迷路の最短経路を見つける」→ A*探索等が適用可能
- 「8パズルの解を求める」→ 状態空間探索で解決
- 「チェスで最善手を決定する」→ ゲーム木探索（ミニマックス法）
- 「ロボットの動作計画を立てる」→ STRIPSなどのプランニング
- 「スケジュールの最適化」→ 制約充足問題として探索

❌ **不適切な選択肢（試験で狙われる）**：
- **「画像から猫と犬を識別する」** → ❌ **最も不適切**（パターン認識、CNNが適切）
- **「音声から文字列に変換する」** → ❌ 音響モデル+言語モデル（RNN等）が必要
- **「文章の感情を分析する」** → ❌ 自然言語処理、Transformerが適切
- **「手書き数字を認識する」** → ❌ 画像認識、CNNが適切
- **「株価を予測する」** → ❌ 時系列予測、統計/機械学習が適切
- **「異常なデータを検出する」** → ❌ 教師なし学習、統計的手法

### 比較されやすい概念
- **BFS** vs **DFS**: 階層順 vs 深さ優先、キュー vs スタック、最短保証 vs なし
- **BFS** vs **A***: 盲目的探索 vs ヒューリスティック探索
- **DFS** vs **反復深化**: 無制限深さ vs 段階的深さ制限
- **A*** vs **ダイクストラ**: ヒューリスティックあり vs なし
- **記号的AI** vs **サブシンボリックAI**: 探索・推論 vs パターン認識・深層学習
- **離散状態空間** vs **連続状態空間**: 探索適用可 vs 不適

### 引っ掛けポイント
- 「階層ごと」「同じ深さを全て」→ **BFS**（DFSではない）
- 「キュー（FIFO）」→ **BFS**、「スタック（LIFO）」→ **DFS**
- 「最短保証」→ BFS（コスト一定）、A*（許容的ヒューリスティック）
- 「メモリ効率」→ DFS > BFS
- A*の評価関数 $f(n) = g(n) + h(n)$ の意味（実コスト+推定）
- **「画像認識も状態空間として扱えるから探索可能」** → ❌ 理論上可能だが実用的でない（次元の呪い）
- **「音声認識は音素の遷移だから状態探索できる」** → ❌ HMMの時代は使われたが、深層学習が主流
- **「ゲームは深層学習の領域」** → △ AlphaGoは探索+深層学習の組み合わせ（探索も重要）

### 頻出パターン
- データ構造（キュー/スタック）と探索手法の対応
- 探索順序の図からBFS/DFSを判別
- 最短経路問題でBFSまたはA*を選択
- メモリ制約下でDFSを選択
- **画像・音声・自然言語処理は探索手法が不適切**（最頻出）

## 補足
- **実務的観点**：
  - カーナビ・ゲームAIではA*が標準（効率と最適性の両立）
  - Webクローラーでは幅優先が主流（浅い階層を優先）
  - 深い再帰はスタックオーバーフローのリスク（DFS実装時注意）
  - 双方向探索で探索空間を削減（開始・ゴール両方から探索）
- **関連トピック**：
  - [プランニング（STRIPS）](planning.md) - 状態空間探索との組み合わせ
  - [強化学習](../05_machine_learning/reinforcement_learning.md) - 探索と活用のトレードオフ
  - [フレーム問題](frame_problem.md) - 探索空間の爆発
- **発展**：
  - モンテカルロ木探索（MCTS）：ゲームAIで使用
  - ビームサーチ：幅優先の変種（上位k個のみ保持）
  - 分枝限定法：最適化問題での探索
  - ミニマックス法：2人ゲームでの探索
